{
  "hash": "7f8162b3562e1a27f067a11e9ba2c0f5",
  "result": {
    "markdown": "---\ntitle: Using tryCatch for robust R scripts\ndate: '2018-12-20'\ncategories:\n  - Programming Practices\ndescription: A quick introduction to `tryCatch` below, followed by three use-cases I use on a regular basis.\n---\n\n\n![](trycatch.png){fig-align=\"center\"}\n\n\n\n\n\nUsing `tryCatch` to write robust R code can be a bit confusing. I found the help file dry to read. There are some resources which explore `tryCatch`, linked below. Over the years, I have developed a few programming paradigms which I've repeatedly found useful. A quick introduction to `tryCatch` below, followed by three use-cases I use on a regular basis.\n\n# Syntax\n\n`tryCatch` has a slightly complex syntax structure. However, once we understand the 4 parts which constitute a complete `tryCatch` call as shown below, it becomes easy to remember:\n\n-   `expr` : \\[Required\\] R code(s) to be evaluated\n-   `error` : \\[Optional\\] What should run if an error occured while evaluating the codes in `expr`\n-   `warning` : \\[Optional\\] What should run if a warning occured while evaluating the codes in `expr`\n-   `finally` : \\[Optional\\] What should run just before quitting the `tryCatch` call, irrespective of if `expr` ran succcessfuly, with an error, or with a warning\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntryCatch(\n    expr = {\n        # Your code...\n        # goes here...\n        # ...\n    },\n    error = function(e){ \n        # (Optional)\n        # Do this if an error is caught...\n    },\n    warning = function(w){\n        # (Optional)\n        # Do this if an warning is caught...\n    },\n    finally = {\n        # (Optional)\n        # Do this at the end before quitting the tryCatch structure...\n    }\n)\n```\n:::\n\n\n## Hello World example\n\nThis is a toy example showing how a function can use `tryCatch` to handle execution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog_calculator <- function(x){\n    tryCatch(\n        expr = {\n            message(log(x))\n            message(\"Successfully executed the log(x) call.\")\n        },\n        error = function(e){\n            message('Caught an error!')\n            print(e)\n        },\n        warning = function(w){\n            message('Caught an warning!')\n            print(w)\n        },\n        finally = {\n            message('All done, quitting.')\n        }\n    )    \n}\n```\n:::\n\n\nIf x is a valid number, `expr` and `finally` are executed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog_calculator(10)\n## 2.30258509299405\n## Successfully executed the log(x) call.\n## All done, quitting.\n```\n:::\n\n\nIf x is an invalid number (negative, zero, `NA`), `expr` is attempted, and `warning` and `finally` are executed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog_calculator(-10)\n## Caught an warning!\n## <simpleWarning in log(x): NaNs produced>\n## All done, quitting.\n```\n:::\n\n\nIf x is an invalid entry which raises an error, `expr` is attempted, and `error` and `finally` are executed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog_calculator(\"log_me\")\n## Caught an error!\n## <simpleError in log(x): non-numeric argument to mathematical function>\n## All done, quitting.\n```\n:::\n\n\n------------------------------------------------------------------------\n\n# More useful examples\n\n## Use `tryCatch` within loops\n\nThere are cases at work where I have quite large datasets to pre-process before model building can begin. The sources of these data can be varied and thus the quality of these data can vary. While each dataset *should* conform to our data quality standards (datatypes, data dictionaries, other domain-specific constraints), very often these isn't the case. As a result, common data preprocessing functions might fail on few datasets. We can use `tryCatch` within the `for` loop to catch errors without breaking the loop.\n\n*Another toy example:* Say, we have a nested dataframe of the `mtcars` data, nested on the cylinder numbers, and say, we had a few character values in `mpg` which is our response variable.\n\n\n::: {.cell paged.print='false'}\n\n```{.r .cell-code}\n# Example nested dataframe\ndf_nested <- split(mtcars, mtcars$cyl)\n\ndf_nested[[2]][c(4,5),\"mpg\"] <- \"a\"\ndf_nested\n## $`4`\n##                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n## Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n## Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n## Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n## Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n## Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n## Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n## Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n## Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n## Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n## Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n## Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n## \n## $`6`\n##                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n## Mazda RX4        21   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n## Mazda RX4 Wag    21   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n## Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n## Valiant           a   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n## Merc 280          a   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n## Merc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n## Ferrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n## \n## $`8`\n##                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n## Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n## Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n## Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n## Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n## Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n## Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n## Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n## Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n## Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\n## AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\n## Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\n## Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\n## Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n## Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n```\n:::\n\n\nWe wish to run a few custom preprocessors, including taking the log of `mpg`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconvert_gear_to_factors <-\n  function(df) {\n    df %>% \n      mutate(gear = factor(gear, levels = 1:5, labels = paste0(\"Gear_\", 1:5)))\n  }\ntransform_response_to_log <-\n  function(df) {\n    df %>% mutate(log_mpg = log(mpg)) %>% select(-mpg)\n  }\n```\n:::\n\n\nHow do we run our preprocessors over all the rows without error-ing out?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (indx in 1:length(df_nested)) {\n    tryCatch(\n        expr = {\n            df_nested[[indx]] <-  df_nested[[indx]] %>% \n                convert_gear_to_factors() %>% \n                transform_response_to_log()\n            message(\"Iteration \", indx, \" successful.\")\n        },\n        error = function(e){\n            message(\"* Caught an error on itertion \", indx)\n            print(e)\n        }\n    )\n}\n## Iteration 1 successful.\n## * Caught an error on itertion 2\n## <error/dplyr:::mutate_error>\n## Error in `mutate()`:\n## ! Problem while computing `log_mpg = log(mpg)`.\n## Caused by error in `log()`:\n## ! non-numeric argument to mathematical function\n## ---\n## Backtrace:\n##   1. base::tryCatch(...)\n##  10. dplyr:::mutate.data.frame(., log_mpg = log(mpg))\n##  11. dplyr:::mutate_cols(.data, dplyr_quosures(...), caller_env = caller_env())\n##  13. mask$eval_all_mutate(quo)\n## Iteration 3 successful.\n```\n:::\n\n\nWe're able to handle the error on iteration 2, let the user know, and run the remaining iterations.\n\n## Catch issues early, log progress often\n\nAn important component of preparing 'development' code to be 'production' ready is implementation of good defensive programming and logging practices. I won't go into details of either here, except to showcase the style of programs I have been writing to prepare code before it goes to our production cluster.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npreprocess_data <- function(df, x, b, ...){\n    message(\"-- Within preprocessor\")\n    df %>% \n        assertive::assert_is_data.frame() %>% \n        assertive::assert_is_non_empty()\n    x %>% \n        assertive::assert_is_numeric() %>% \n        assertive::assert_all_are_greater_than(3.14)\n    b %>% \n        assertive::assert_is_a_bool()\n    \n    # Code here...\n    # ....\n    # ....\n    \n    return(df)\n}\nbuild_model <- function(...){message(\"-- Building model...\")}\neval_model  <- function(...) {message(\"-- Evaluating model...\")}\nsave_model  <- function(...) {message(\"-- Saving model...\")}\n\nmain_executor <- function(...){\n    tryCatch(\n        expr = {\n            preprocess_data(df, x, b, more_args,...) %>% \n                build_model() %>% \n                eval_model() %>% \n                save_model()\n        },\n        error = function(e){\n            message('** ERR at ', Sys.time(), \" **\")\n            print(e)\n            write_to_log_file(e, logger_level = \"ERR\") #Custom logging function\n        },\n        warning = function(w){\n            message('** WARN at ', Sys.time(), \" **\")\n            print(w)\n            write_to_log_file(w, logger_level = \"WARN\") #Custom logging function\n        },\n        finally = {\n            message(\"--- Main Executor Complete ---\")\n        }\n    )\n}\n```\n:::\n\n\nEach utility function starts with checking arguments. There are plenty of packages which allow run-time testing. My favorite one is [assertive](https://cran.r-project.org/web/packages/assertive/index.html). It's easy to read the code, and it's pipe-able. Errors and warnings are handled using `tryCatch` - they are printed to the console if running in interactive mode, and then written to log files as well. I have written my own custom logging functions, but there are packages like [logging](https://cran.r-project.org/web/packages/logging/logging.pdf) and [log4r](https://cran.r-project.org/web/packages/log4r/index.html) which work perfectly fine.\n\n## Use `tryCatch` while model building\n\n`tryCatch` is quite invaluable during model building. This is an actual piece of code I wrote for a kaggle competition as part of my midterm work at school. [Github link here](https://github.com/rsangole/413_midterm_kaggle). The details of what's going on isn't important. At a high level, I was fitting `stlf` models using [`forecast`](https://www.rdocumentation.org/packages/forecast/versions/8.4/topics/forecast.stl) for each shop, among 60 unique shop-ID numbers. For various reasons, for some shops, an `stlf` model could not be be fit, in which case a default seasonal naive model using `snaive` was to be used. `tryCatch` is a perfect way to handle such exceptions as shown below. I used a similar approach while building models at an \"item\" level: the number of unique items was in the 1000s; manually debugging one at a time is impossible. `tryCatch` allows us to programatically handle such situations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstlf_yhats <- vector(mode = 'list', length = length(unique_shops))\nfor (i in seq_along(unique_shops)) {\n    cat('\\nProcessing shop', unique_shops[i])\n    tr_data <- c6_tr %>% filter(shop_id == unique_shops[i])\n    tr_data_ts <-\n        dcast(\n          formula = yw ~ shop_id,\n          data = tr_data,\n          fun.aggregate = sum,\n          value.var = 'total_sales',\n          fill = 0\n        )\n    tr_data_ts <- ts(tr_data_ts[, -1], frequency = 52)\n\n    ##################\n    # <--Look here -->\n    fit <- tryCatch(\n      expr = {tr_data_ts %>% stlf(lambda = 'auto')},\n      error = function(e) { tr_data_ts %>% snaive()}\n      )\n    ##################\n  \n    fc <- fit %>% forecast(h = h)\n    stlf_yhats[[i]] <- as.numeric(fc$mean)\n    stlf_yhats[[i]] <- ifelse(stlf_yhats[[i]] < 0, 0, stlf_yhats[[i]])\n}\n```\n:::\n\n\nHope this is useful to others learning `tryCatch`. Cheers.\n\n# Links\n\n-   https://www.rdocumentation.org/packages/R.oo/versions/1.2.7/topics/trycatch\n-   https://www.r-bloggers.com/careful-with-trycatch/\n-   http://adv-r.had.co.nz/Exceptions-Debugging.html\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}