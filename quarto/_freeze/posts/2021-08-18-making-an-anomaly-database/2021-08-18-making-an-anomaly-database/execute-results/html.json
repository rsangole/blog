{
  "hash": "c7be5c58b932a19b0d9eeaaf0c7603bd",
  "result": {
    "markdown": "---\ntitle: Making the Anomaly Database\ndate: '2021-08-18'\ncategories:\n  - Docker\n  - Postgres\n---\n\n\n\n\n*This is part two of the two part post related to Docker, Postgres databases and Anomaly data-sets. Read [Part 1](https://rsangole.netlify.app2021/08/07/docker-based-rstudio-postgres/), which teaches you how to setup a new postgres database using Docker.*\n\nThis post describes how you populate the anomaly database built in Part 1.\n\n# Motivation\n\nContinuing the theme of end-to-end reproducible workflows, I want to be able to recreate my raw database programmatically as well.\n\nAt the end of this activity, I'm able to quickly load and manage \\~6G of data for my personal use.\n\n![](anomaly-db-vscode.gif)\n\nThe entire codebase for populating the database is in my [GitHub repo](https://github.com/rsangole/anomaly_db).\n\n# Who should read this?\n\nIf you're comfortable using `download.file()`, system commands, `arff` file formats, and `{DBI}` you won't learn much here. Read on if you're curious about my approach.\n\n# Steps\n\nOnly three files here:\n\n1.  Initial Setup ([`00-execute.R`](https://github.com/rsangole/anomaly_db/blob/master/00-execute.R))\n2.  Download data from the web ([`01-download-data.R`](https://github.com/rsangole/anomaly_db/blob/master/01-download-data.R))\n3.  Load data into `anomaly` database in Postgres ([`02-load-data-to-postgres.R`](https://github.com/rsangole/anomaly_db/blob/master/02-load-data-to-postgres.R))\n\n### Initial Setup\n\nA list helps be keep track of the data sources, and helps me turn any downloads off to save on space/time (the Monash one is a \\~2G download, for example).\n\n``` r\ndatasets <- list(\n  ionosphere = TRUE,\n  nab = TRUE,\n  monash = TRUE, # 2G download, 6G uncompressed\n  ucr = TRUE\n)\n```\n\nSome simple housekeeping to ensure directories are setup correctly. Furthermore, if the folder is git controlled, the directory which will house the datasets `large_data` needs to be in `.gitignore`. I check for this.\n\n``` r\n# create large_data/ if does not exist\nif (!fs::dir_exists(here::here(\"large_data\"))) {\n  cli::cli_alert(\"{here::here('large_data')} does not exist\")\n  resp <-\n    usethis::ui_yeah(\n      \"Create {here::here('large_data')}?\",\n      yes = \"Y\",\n      no = \"N\",\n      shuffle = F\n    )\n  if (!resp)\n    stop()\n  fs::dir_create(here::here(\"large_data\"))\n}\n\n# git but no gitignore?\nif (fs::dir_exists(here::here(\".git\")) &\n    !fs::file_exists(here::here(\".gitignore\"))) {\n  cli::cli_alert_danger(\n    \"You have a git project, but no .gitignore. You must add {here::here('large_data')} to .gitignore since the data are massive.\"\n  )\n  stop()\n}\n\n# gitignore but large_data missing?\nif (fs::file_exists(here::here(\".gitignore\")) &\n    !any(grepl(\"large_data\", readLines(here::here(\".gitignore\"))))) {\n  cli::cli_alert_danger(\n    \"Your .gitignore does not have `large_data` specified. Add this to continue, since the data are massive.\"\n  )\n  stop()\n}\n```\n\n### Download Data\n\nNow, for those datasets in the list above, simply download the data using `download.file()` for the selected datasets and move/unzip them to the `large_data` folder. I'm also checking if the folder already exists, and I'd like to overwrite it.\n\nHere's an example for the UCR dataset. The code for the rest of the datasets is pretty similar.\n\n``` r\nif(datasets$ucr){\n  DIR <- here::here(\"large_data/UCRArchive_2018\")\n  resp <- T\n  if(fs::dir_exists(DIR)){\n    resp <- usethis::ui_yeah(\"{DIR} already exists. Re-download data?\", \"Y\", \"N\", shuffle = F)\n    fs::dir_delete(here::here(\"large_data/UCRArchive_2018\"))\n  }\n  if(resp){\n    download.file(url = \"https://www.cs.ucr.edu/%7Eeamonn/time_series_data_2018/UCRArchive_2018.zip\",\n                  destfile = here::here(\"large_data/UCRArchive_2018.zip\"))\n    system(command = glue::glue('unzip -P someone {here::here(\"large_data/UCRArchive_2018.zip\")} -d {here::here(\"large_data\")}'))\n    fs::file_delete(here::here(\"large_data/UCRArchive_2018.zip\"))\n  }\n}\n```\n\n### Load Data\n\nNow, it's as easy as:\n\n1.  Connect to the postgres database using `DBI::dbConnect`\n2.  Read a dataset from `large_data/`\n3.  Simple cleanup (`janitor::clean_names`, all timestamp cols are called `time` etc)\n4.  Use `DBI::dbWriteTable` to load the data into postgres\n\nHere's an example codebase:\n\n``` r\n# DB Connection ----\ncon <- DBI::dbConnect(\n  drv = RPostgres::Postgres(),\n  dbname = \"anomaly\",\n  host = \"db\",\n  user = \"rahul\",\n  password = \"pass\",\n  port = 5432\n)\n\nif (datasets$ionosphere) {\n  dat <-\n    read_csv(\"large_data/ionosphere/ionosphere.data\", col_names = F) %>%\n    rename(class = X35)\n  DBI::dbWriteTable(con, \"ionosphere\", dat)\n\n# Quick check\n  con %>% dplyr::tbl(\"ionosphere\")\n  \n}\n```\n\n*For the monash dataset, you do need to use [`foreign::read.arff()`](https://stat.ethz.ch/R-manual/R-devel/library/foreign/html/read.arff.html).*\n\n------------------------------------------------------------------------\n\n# Tips\n\n**Large file downloads** will timeout within the default timeout-window of 1 min. Handle this before calling `download.file()`.\n\n``` r\ntimeout.existing <- getOption(\"timeout\")\non.exit(options(timeout = timeout.existing))\noptions(timeout = 60*60)\n```\n\n**Data dictionaries** can be stored directly in the DB too. I store the contents of each `README.md` in the `UCR_Archive2018/*` folder in a data dictionary table called `ucr_00_meta`. This allows me to programatically call the dictionary in downstream development.\n\n![](ucr_00_meta.png)\n\n**Shiny** can be effectively used for quick exploration. Here's an example of something I'm building for myself. The dashboard pulls data from PostgreSQL directly. UCR metadata is also pulled from the db rendered at the top of each page, making it quick to browse through the datasets. As I add more datasets, I keep expanding this dashboard.\n\n![](anomaly-db-shiny.gif)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}